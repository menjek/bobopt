%\addcontentsline{toc}{chapter}{Conclusion}
\chapter{Conclusion}
The Bobox project is a framework for task-based parallel computing. The task-based approach relieves a programmer from various issues necessary to handle in the thread-based approach. It is definitely an approach that will be primarily used in the future. Nowadays, most parallel computing software has already made the transition to the task-based implementation. The rest is encouraged to do so.

However, parallel computing is not for free even in the task-based environment. The environment handles programming issues related to parallel computing and it does bring some overhead. This overhead concentrates in times when a task starts and finishes its execution. Thus, tasks should run for enough time to make this overhead negligible. The prefetch optimization method tries to  reduce special cases of short-running tasks. Running a task without necessary input data causes this task to finish almost immediately. This method detects such tasks and informs the Bobox framework about their input requirements. The analysis makes some assumptions, which can result in false positives. However, if a task accesses input data using some of expected ways, this method detects it. The scheduling mechanism in the Bobox framework is greatly optimized. The gain in a speed is not overwhelming even in cases where this optimization method excessively reduces an amount of unnecessary scheduling. On the other hand, there is no reason to refuse any gain in an application speed.

The Bobox cooperative scheduling of tasks brings another responsibility on a task developer. A task should not run for a long time. If a task produces data for other tasks, it can inhibit the parallel execution, because other tasks wait until this task finishes. It can also congest internal framework structures. Such task should yield its execution after some time. The yield complex optimization method detects complex tasks and injects yields to appropriate places in code. Measuring a complexity by the static analysis is a hard task since the real complexity tightly depends on input data. The analysis has to make many assumptions about code, thus it results in more false positives. Nonetheless, the yield operation is not harmful to a performance. On one side, it can greatly help an application performance, on the other side, it will not hurt its performance unless its excessive usage. The method analyses general C++ code and the only related operation to the Bobox framework is the yield call. Thus, anyone who is interested in the code complexity can reuse the algorithm. This optimization method shows a great potential in the measured use case. Even though, the use case is artificial, it can appear in some context in more complex models. Furthermore, there are more use cases where a bigger task granularity helps.

The only concern for both methods is the possible high ratio of false positives. Both methods make assumptions about code, e.g., a loop body is executed at least once. Therefore, the prefetch method can introduce prefetch of some input data even though a task is able to do some work without it. The yield complex method can place yield after a loop whose body is not executed, thus introduce a short-running task. A user of the tool should know about these drawbacks and use it carefully. However, the tool provides diagnostic and interactive modes, which are very useful and harmless.

\section{Future work}
The tool is designed for further enhancements like adding new optimization methods or improving the implementation of current ones. Some ideas for future improvements of the yield optimization method are mentioned in Section~\ref{yield-future}.

Furthermore, the tool is implemented as a standalone tool, but because it is implemented on top of LibTooling and AST matchers libraries, it can be easily implemented as a Clang plugin, sharing a big part of codebase. There are also possibilities of improvements in the internal tool implementation. The tool currently uses the \code{Rewriter} class for source-to-source transformation, but the recommended approach is to use the \code{TreeTransform} class. In the tool usage, diagnostic messages can be more verbose. Even though data from an analysis is available in the tool, there is no simple way to display them to a user. One issue was also encountered during the development. The tool cannot run in parallel, which can be major issue when using the tool in a build environment.

However, when the tool was designed, most of mentioned issues and missing features were already known so they are included in the design. During the development, the main focus was on the implementation of the optimization methods and used algorithms. The future work consist mainly from fixing issues, improving the implementation and the interaction with a user.