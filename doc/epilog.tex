%\addcontentsline{toc}{chapter}{Conclusion}
\chapter{Conclusion}
The Bobox project is a framework for task-based parallel computing. The task-based approach relieves a programmer from various issues necessary to handle in the thread-based approach. It is definitely a sound of the future. Nowadays, the most of parallel computing software has already moved to the task-based implementation. The rest is encouraged to do so.

However, even in the task-based environment, parallel computing is not for free. The environment handles issues related to parallel computing and it does bring some overhead. This overhead concentrates in times when a task starts and finishes its execution. Thus, tasks should run for enough time to make this overhead negligible. The prefetch optimization method tries to  reduce special cases of short-running tasks. Tasks in the Bobox framework can have inputs. Running a task without necessary input data causes this task to finish almost immediately. The method detects such tasks and informs the Bobox framework about their input requirements. Proving that something happens in code is searching for its occurrence on all paths in CFG. The issue is detection of expressions with the meaning that data from some input is necessary. The analysis makes some assumptions, which can result in false positives. However, if a task accesses input data using some of expected ways, this method detects it.

The Bobox framework implements cooperative scheduling of tasks and it brings another responsibility on a task developer. A task should not run for a long time. If a task produces data for other tasks, it can inhibit the parallel execution, because other tasks wait until this task finishes. It can also congest internal framework structures. Such task should yield its execution after some time. The yield complex method detects complex tasks and injects yields to appropriate places in code. Measuring complexity by static analysis is a hard task since the real complexity tightly depends on input data. The analysis has to make many assumptions about code, thus it results in more false positives. Nonetheless, the yield operation is not harmful to a performance. On one side, it can greatly help a performance, on the other side, it will not hurt a performance unless its excessive usage. The method analyses general C++ code and the only related operation to the Bobox framework is the yield call. Thus, anyone who is interested in the code complexity can reuse it. Even though the analysis and used constants are adjusted to work on some tested scenarios, testing on a bigger code sample gave surprisingly good results.

The only concern for both methods is the possible high ratio of false positives. Both methods make assumptions about code, e.g., a loop body is executed at least once. Therefore, the prefetch method can introduce prefetch of some input data even though a task is able to do some work without it. The yield complex method can place yield after a loop whose body is not executed, thus introduce a short-running task. A user of the tool should know about these drawbacks and use it carefully. However, the tool provides diagnostic and interactive modes, which are very useful and harmless.