%\addcontentsline{toc}{chapter}{Conclusion}
\chapter{Conclusion}
The Bobox project is a framework for task-based parallel computing. The task-based approach relieves a programmer from various issues necessary to handle in the thread-based approach. It is definitely an approach that will be primarily used in the future. Nowadays, most parallel computing software has already made the transition to the task-based implementation. The rest is encouraged to do so.

However, parallel computing is not for free even in the task-based environment. The environment handles programming issues related to parallel computing and it does bring some overhead. This overhead concentrates in times when a task starts and finishes its execution. Thus, tasks should run for enough time to make this overhead negligible. The prefetch optimization method tries to  reduce special cases of short-running tasks. Running a task without necessary input data causes this task to finish almost immediately. This method detects such tasks and informs the Bobox framework about their input requirements. The analysis makes some assumptions, which can result in false positives. However, if a task accesses input data using some of expected ways, this method detects it. The scheduling mechanism in the Bobox framework is greatly optimized. The gain in a speed is not overwhelming even in cases where this optimization method excessively reduces an amount of unnecessary scheduling. On the other hand, there is no reason to refuse any gain in an application speed.

The Bobox cooperative scheduling of tasks brings another responsibility on a task developer. A task should not run for a long time. If a task produces data for other tasks, it can inhibit the parallel execution, because other tasks wait until this task finishes. It can also congest internal framework structures. Such task should yield its execution after some time. The yield complex optimization method detects complex tasks and injects yields to appropriate places in code. Measuring a complexity by the static analysis is a hard task since the real complexity tightly depends on input data. The analysis has to make many assumptions about code, thus it results in more false positives. Nonetheless, the yield operation is not harmful to a performance. On one side, it can greatly help an application performance, on the other side, it will not hurt its performance unless its excessive usage. The method analyses general C++ code and the only related operation to the Bobox framework is the yield call. Thus, anyone who is interested in the code complexity can reuse the algorithm. This optimization method shows a great potential in the measured use case. Even though, the use case is artificial, it can appear in some context in more complex models. Furthermore, there are more use cases where a bigger task granularity helps.

The only concern for both methods is the possible high ratio of false positives. Both methods make assumptions about code, e.g., a loop body is executed at least once. Therefore, the prefetch method can introduce prefetch of some input data even though a task is able to do some work without it. The yield complex method can place yield after a loop whose body is not executed, thus introduce a short-running task. A user of the tool should know about these drawbacks and use it carefully. However, the tool provides diagnostic and interactive modes, which are very useful and harmless.