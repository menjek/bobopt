\chapter{Introduction}
The Bobox project as a framework for parallel computing can have bad uses in terms of performance as well as any other software framework. Static code analysis can be used to detect and repair such bad uses. Since the core and interface language of Bobox framework is C++, static code analysis becomes accordingly difficult to lack of tools. This has been the biggest pitfall for any static analysis of C++ code. However, it has become less marginal with growing support for tooling in Clang front-end. Clang exposes C++ code as a user-friendly \emph{Abstract Syntax Tree (AST)} structure.

\section{Goals}
Apart from this text, the main asset is tool for optimization of code using Bobox framework. By analysing AST, tool is able to diagnose and potentially transform bad uses of the framework. There is an implementation of two different patterns of unoptimized usage in context of this thesis, but tool is designed to be easily extensible with new optimization methods. Both implemented optimization methods are able to inject new code to hint Bobox internal facilities\footnote{Both methods hint Bobox scheduler in particular.} about user code structure. Tool is able to perform source-to-source transformations so it can be used in build process as an pre-compile optimizer. Tool is implemented using Clang tooling API. Therefore, it inherits all Clang front-end limitations such as platform support.

\section{Structure of thesis}
Text begins with brief description of Bobox framework to familiarize reader with its underlying mechanisms. Reader should understand why user code can be optimized using transformations mentioned later in chapters related to specific optimization methods.

The next chapter describes problems of static code analysis firstly in general, then specifically for C++ language since it is core and interface language of Bobox framework. Chapter mentions possible approaches for static code analysis of C++ code, their advantages and disadvantages, internal algorithms, user interface and limitations. Last section addresses related work. Nonetheless, the most of the mentioned tools are related to thesis only in terms of static code analysis and only two of them are able to transform code in some way.

Because the chosen approach to implement optimizer tool was Clang tooling interface, the next chapter is completely dedicated to its detailed description. Tools implemented on top of Clang front-end are provided with abstract syntax tree representation of code. One section describes design of this data structure. Possibilities of source-to-source transformations are described in the following section. Clang front-end itself provides multiple interfaces for implementation of static code analysis tools so there is a section for every one of them. Subsections of one of the tooling interface sections contain information about compiler internals, which are accessible from optimizer code.

Own work is described in the following chapters starting with high-level look on tool design followed by description of implemented optimization methods and ending with achieved results. Each method is addressed in separate chapter with detailed description. Each chapter contains sections with information related to Bobox framework, detailed description of algorithm used to detect unoptimized usage of the framework and other details of implementation.