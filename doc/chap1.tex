\chapter{Bobox}
Nowadays, increasing performance comes with increasing number of computational units due to reach of physical limits of current technologies. Parallel programming becomes more and more essential in development of performance expensive software to use all the silicon hardware provides. Thread based approach to achieve parallelism creates a lot of complexity for programmer to maintain and is also not well scalable. It is important to abstract underlying parallel environment to programmer. The Bobox project addresses this issue by using task based parallel environment. Apart from relieving programmer of handling thread based programming problems such as synchronization, the most technical details (cache hierarchy, CPU architecture, etc.) and communication, task based programming allows also better hardware utilization.

Implementation of the Bobox project sacrifices generality to better performance in certain class of problems, specifically data processing problems. Without further details, under the hood, it is implemented with a fixed number of worker threads, each one with own scheduler, two task queues (for better utilization of CPU caches), using task stealing mechanism. Communication between tasks uses column based data model, the most significant implementation detail that advance data processing problems. Each task has zero or more inputs and zero or more outputs. Output can be connected to zero or more inputs. Task is scheduled to be executed, when it has unprocessed input.

The Bobox project provides C++ library as an interface to its runtime environment. Task granularity is represented by classes derived from Bobox base class for task, called box.

\section{Design and Terminology}
Runtime environment handles scheduling and parallel execution of tasks, data transport, control flow, etc. User uses declarative way to provide environment a \textit{model}, which defines the way individual tasks are connected. Model is used to create \textit{model instance}, which is base for creation of \textit{user request}. User request does contain only a very little additional information to model instance.

When user provides user request to the environment, he has no longer control over its execution. The only possible query is whether runtime environment finished execution of user request. After user provided user request, model instance is separated to individual tasks. When task is ready to be executed, in the meaning it has unprocessed input, it is added to the task pool. Worker thread then retrieves task from task pool and invokes this task.

The basic element of model instance is element representing task called \textit{box}.  As already mentioned, every box has zero or more inputs and zero or more outputs. In every model instance, there's special box called \textit{initialization box}. This box is responsible for creation of initialization inputs of other boxes in model. It is executed at the beginning of evaluation and all it does is sending data to its only input.

The link that connects boxes is called \textit{via}. Via represents one way connection between single output and one or more inputs. When box sends data to its input, it actually sends data to via. Via then creates copies of data for every input. Data are sent through via using \textit{envelope}, column base data structure. Empty envelope is special type of envelope called \textit{poisoned pill}. When box receives poisoned pill on its input, it means that there will be no more data send to this input. All paths of model instances are required to end in another special type of box called \textit{termination box}. When this box receives poisoned pill, execution is finished and pipeline is deallocated.

\section{Boxes}
Boxes as representation of Bobox tasks are executed in three steps. The first step is \textit{prologue}, when box creates a snapshot of its inputs and stores it in member variable so user code can access it. Prologue communicates with runtime environment so synchronization is necessary. The second step, called the \textit{action}, is the only place for user code execution. User code can communicate with runtime environment using only specific member functions (e.g. it can send envelope to its output). This creates transparent parallel environment to user code relieving it from issues related to parallel execution. The last step is \textit{epilogue}, which handles next task scheduling based on two criteria. The task is scheduled again if it has unprocessed input and processed some input in the \textit{action} step or it requested to be scheduled again, in the meaning user code set specific flag on box object using its member function. The reason why box is not scheduled again if it has unprocessed input and it haven't processed any in the \textit{action} step is that it very probably waits for another input. Example can be join operation in databases, when task won't execute until it has data on both inputs. Possibility to explicitly request another scheduling is for cases where single box creates large output. It is not desirable to let it run for a long time creating big output and congest internal buffers used for communication. Task running for a long time on single worker thread can also create bottleneck for parallel execution when a lot of tasks can wait for input from this task.

As the main place for user code, boxes are the main object of optimization. Based on static analysis of the \textit{action} step, code can be injected to hint scheduler with information.

\section{Usage}
The action step in box task execution is the main place for user code. User code communicates with runtime environment using box member functions. When creating box, programmer needs to inherit from bobox:box base class. The action step is represented by virtual body() member function that has to be overridden in derived class, otherwise empty body of base will be executed. Inputs and outputs of a box are defined using Bobox library macros.

Creating task for execution model is pretty straightforward for any C++ programmer using only C++ core language features. Unfortunately, C++ syntax is not handy to express definition of whole execution model. It is definitely possible, but any approach using C++ syntax could be considered inferior to approach using different language and syntax in ease of definition and readability. Authors of Bobox developed own language called Bobolang to such purpose.
