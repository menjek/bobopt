\chapter{Clang and tooling}
\label{chapter-clang}
A support for creating static code analysis tools for C++ was very subtle. All compiler front-ends were cumbersome for a usage and individually implementing a new front-end is extremely difficult. The situation has changed with Clang providing API for an access to C++ code represented as user-friendly abstract syntax tree structure. Actually, Clang does not provide single tooling API, rather multiple APIs with differences in a usage. Differences affect mainly the way a tool accesses AST, range of accessed information and compatibility with older versions. A tool developer can decide whether he wants to sacrifice compatibility to all information front-end internals provide. As Clang develops, there is no guarantee that interfaces in their code base do not change.

The tooling interface indicates that Clang targets to diagnostic, code completion and refactoring tools. The support of source-to-source transformation is subtle. Even though there are multiple ways to transform code, the most of them are deprecated.

\section{Abstract Syntax Tree}
The structure Clang provides is not only abstract syntax tree of code, it is a graph that has AST as its sub-graph. Clang provides mechanisms to traverse this graph as if it was AST. With an access to the AST node, a programmer is able to traverse a graph in more ways than he would be able to do with the purely AST structure. It allows a developer to optimize his analysing code or perform a context sensitive traversal.

Unusually, the class hierarchy of nodes does not have the common ancestor. There are two large hierarchies with common ancestors in \code{Decl} and \code{Stmt} classes, some important ones with ancestors in \code{Type} and \code{DeclContext} classes, and many classes accessible only from specific nodes. The AST traversal starts in the \code{TranslationUnitDecl} node. 

\subsection{Traversal}
\label{clang-ast-traversal}
The template responsible for the AST traversal is called \code{RecursiveASTVisitor}. It is implemented as \emph{Curiously Recurring Template Pattern (CRTP)} combined with the \emph{visitor design pattern} where a programmer is able to either react on the AST node visit or manipulate with a traversal. Due to the character of the AST nodes class hierarchy, the implementation of the visitor is a bit cumbersome with the extensive usage of macros. Therefore, it has nickname \textit{macro monster}. It was promised that it will be once reimplemented so there is no guarantee that the interface will not change, even though the visitor is massively used in tools. The other approach to traverse AST is to follow edges. It is more useful in a context sensitive traversal.

\section{Source-to-source transformation}
Developers try to use automatic source-to-source transformations very carefully. Even the simplest case of a code transformation such as symbol renaming is difficult to implement in C++. Before the lexical analysis starts, with some exceptions\footnote{The token paste operator \code{\#\#} must be handled when the lexical analysis is happening.}, there is a text-preprocessing phase when source code \emph{text} is transformed to different source code \emph{text}. A preprocessor does not know anything about language syntax or semantic, it is defined as a set of operations on text. During the preprocessing phase, symbols may be created, copied, or erased. It is a difficult task to track symbols origin from the output of the syntactic analysis to a source code location before preprocessing. Clang uses the integrated preprocessor so looking up a source location from AST is simpler.

There are multiple approaches to do source-to-source transformations based on tool objectives. If a tool is supposed to support operations such as symbol renaming or code completion, Clang allows a programmer to rewrite source code as text. The \code{Rewriter} class provides this functionality. For a bigger control over code changes in specialized tool wrappers, there is the \code{Replacement} class. If a tool is supposed to be used in a build process, it is the best solution to transform AST and output code from this transformed AST for a next build step.

\subsection{Rewriter}
For basic source code transformations on the level of text editing, there is the \code{Rewriter} class. A programmer can create as many instances as necessary, passing them a reference to \code{SourceManager}. A user is then allowed to do operations such as insertion, removal, or replacement of text using \code{SourceLocation} or \code{SourceRange} objects. Both can be gathered directly from the AST node. Text transformations are far from ideal in C++. Though, it is sufficient for renaming of symbols or code completion in a text editor, where a programmer can immediately repair caused compilation errors.

\subsection{Replacements}
The special wrapper for a bigger control over operations on the \code{Rewriter} class is called  \code{Replacement}. When using AST matchers, a callback function is provided with \code{Replacements}, which is a container of \code{Replacement} objects. A callback is free to manipulate with this set, e.g., primarily by adding new objects, but it is not prohibited from removing or editing existing items. At the end of an analysis, a tool tests whether an analysis finished correctly. Then it checks \code{Replacement} objects for validity and if all tests pass, it applies those objects on the \code{Rewriter} object. After all \code{Replacement} objects are successfully applied to the \code{Rewriter} object, the last step is to save affected files.

When using \code{Rewriter}, a programmer should implement all the mentioned steps for the correct usage. The problem arises when a developer wants to refactor code with compilation errors. \code{RefactoringTool} will not save any changes when an analysis fails. Refactoring tools integrated to a source code text editor cannot use these facilities. Furthermore, text editor tools need to react as fast as possible to user input. A developer should consider using output of \code{Lexer} and avoid phases of syntactic and semantic analysis\footnote{A similar discussion between developers is conducted on the \emph{clang-format} implementation, see subsection \ref{clang-format}.}.

\subsection{TreeTransform}
The most correct approach to AST transformations according to Clang developers is to use the \code{TreeTransform} facility. If a programmer has an access to non-const nodes, they often provide member functions for a manipulation with \textit{edges} to other nodes. The Scout tool, see subsection \ref{scout}, uses this approach even though it is deprecated. The problem is that nodes and edges actually create a more complex structure than AST. It is difficult to manipulate with this structure without its detailed knowledge, i.e., a knowledge on the level of the Clang developer. A developer has to know what is responsible for a node lifetime, what objects can point to the node so deleting the node does not leave any dangling pointer or reference, and all necessary edges starting from the new node so the AST structure will not be incomplete. It is encouraged not to try to modify AST manually.

On the other hand, Clang itself internally transforms AST multiple times in a compilation process. For example, a template instantiation is done on constructed AST effectively transforming it to different one. Since a template instantiation can break the code semantic, it is necessary to test newly created AST in the semantic analysis represented by the \code{Sema} class. This process is handled by the \code{TreeTransform} class. Even though its interface is simple, using the CRTP pattern, it is hard to use it in tools. None of Clang tooling interfaces provide an access to the \code{Sema} object.

\section{libclang}
The first mentioned, but the least suitable tooling API to achieve the thesis goal is libclang \cite{clang-libclang}, a library with an interface in the C language. Its major advantage presented by Clang developers is that it is supposed to be relatively stable and backward compatible. For some developers it can be the crucial feature, but it is negligible to achieve the thesis goal.

Even though libclang provides the interface in a different language than Clang internals, it does not try to hide the way code is represented there. It provides an access to Clang AST\footnote{It is necessary to mention that the access is very limited relatively to Clang internal AST.} in form of abstraction called \emph{Cursor}, which represents a single AST element. A tree traversal is achieved using the \emph{visitor design pattern}. A part of the library supports code completion, thus the library fits well as basis for source code text editors tools.

\section{Plugins}
Clang allows a developer to step into a compilation process in form of plugins \cite{clang-plugins}, dynamic libraries loaded in runtime and running their actions on processed code. Plugins are easy to integrate into a build environment where Clang is used as compiler. They can be used to break a compilation (e.g. coding rules are broken) or they can produce some output (e.g. code statistics). Because plugins are already a part of a single compilation step, they are not suitable for source-to-source transformations. Unlike using libclang, a developer of Clang plugins has full access to AST.

Even though the purpose of this thesis is to create a tool used mainly in a build environment, it should not be limited to environments where Clang is used as compiler or force build environments to integrate Clang in any way.

\section{LibTooling and AST matchers}
LibTooling \cite{clang-libtooling} aims at writing standalone tools such as checkers or refactoring tools. It is easier to run a standalone tool on a single file or specific set of files. On the other hand, it is harder, but definitely possible, to integrate such tool into a build environment where it can be triggered on dependency changes.

The library interface provides a developer with a full access to the AST structure. Even though the interface tries to hide other compiler internals, it is a part of compiler code so it can be obfuscated to access them. A developer can take an advantage of other powerful facilities in the compiler such as \code{Lexer}, \code{Parser}, \code{Sema}, \code{SourceManager}, \code{TreeTransform} and more.

AST matchers \cite{clang-matchers} aim at solving the very fundamental operation of matching patterns in AST. The most tools do not invoke an action on every single node in AST, rather they invoke an action only on specific nodes, e.g., nodes representing a member call expression on a specific class. Without AST matchers, a programmer has to traverse a whole tree looking for patterns, and eventually invoke an action on matching nodes. Clang provides the extensive library of matcher classes, which are designed to be combinable. For example, matchers for the \code{if} statement and function call expression can be combined to the matcher for the \code{if} statement where the condition is an expression in form of a function call.

Both libraries are part of Clang source code and unlike libclang, they do not abstract compiler internal structures. They only represent the way those structures are accessed. Therefore, both libraries can be used interchangeably, e.g., a developer can use AST matchers to seek nodes in AST, then he can run a front-end action on a sub-tree using LibTooling.

\subsection{Internals}
Every compiler front-end uses some powerful facilities in a compilation process. With the access to these facilities, a developer has the access to more information about source code. More information allows an implementation of more complex algorithms. If those facilities are accessed before their invocation, a tool can also affect the compilation process.

\subsubsection{Preprocessor}
The \code{Preprocessor} module tightly cooperates with lexer in a transformation of a source code text into lexical tokens. The \code{Lexer} class should see code as single source file. It should not handle code preprocessing actions such as resolving file includes and macro expansions. The integrated preprocessor gives Clang tooling libraries an edge over other libraries in the implementation of tools performing source-to-source transformations. The integrated preprocessor allows better tracking of macro expansions and seeking source code locations from AST nodes. Some of useful information provided by the Clang preprocessor is:

\begin{itemize}
\item The list of all predefined macros.
\item The access to the immediate macro name for a source code location.
\end{itemize}

\subsubsection{Lexer}
The \code{Lexer} class provides a simple interface for the transformation of the text buffer into the stream of tokens. Only forward lexing is supported. The class provides:

\begin{itemize}
\item The source location just past the end of the token specified by the provided source code location.
\item The token string for the provided source location.
\end{itemize}

\subsubsection{Parser}
The compiler parser is implemented in the \code{Parser} class. The class implements the parser for the C family of languages, i.e., C, Objective C, C++ and Objective C++. Clang implements own hand-written recursive-descent parser as several other C and C++ front-ends do\footnote{GCC used the generated Bison/YACC parser, but authors implemented own hand-written parser in the end. Elsa uses the recursive-descent parser as well.}. Due to being recursive-descent and complexity of the C++ grammar, \code{Parser} is a relatively large class in terms of member functions count. However, it is not an interesting class for tools. The majority of member functions handle the grammar rules resolution and are context sensitive.

\subsubsection{Sema}
\code{Parser} feeds the \code{Sema} object with information using the \code{Action} interface. Essentially, when code is being parsed, \code{Parser} notifies \code{Sema}. Based on notifications, the \code{Sema} object constructs the AST structure. After a whole translation unit is parsed, the \code{ActOnEndOfTranslationUnit} action is invoked and \code{Sema} provides \code{ASTConsumer} with constructed AST. This is the point where plugins and LibTooling libraries start a code analysis by providing own \code{ASTConsumer} implementation through the \code{FrontendAction} interface.

\code{Sema} is one of the most interesting classes for tools from outside of the AST library. It provides information related to:

\begin{itemize}
\item Name lookup.
\item Semantic checks.
\item Code completion.
\end{itemize}

\subsubsection{SourceManager}
The class essential for tools performing source-to-source transformations is called \code{SourceManager}. It is responsible for a source code management on top of a filesystem. It handles loading and caching of source code. Furthermore, the class is able to translate abstract \code{SourceLocation} objects into \emph{spelling} and \emph{expansion} locations. A spelling location is a location where bytes for a specified token come from, and an expansion location where programmer can see them. For a macro expansion, a spelling location is a location in a macro definition, and an expansion location is a location where a macro was expanded. \code{SourceManager} provides some useful information such as:

\begin{itemize}
\item Spelling and expansion line and column numbers.
\item Whether a location is in a system header.
\item Whether a location is in the main translation unit file.
\item Whether a location is in a macro expansion.
\item The memory buffer for translation unit source code.
\item Various macro expansion information.
\end{itemize}

\subsection{Usage}
Clang, as the most other compilers, can receive compilation options such as predefined macros, include directories, forced includes or diagnostic level as command line arguments. A standalone tool must be able to feed the compiler internally with this kind of data. Since a tool can have its own command line arguments, it would be hard to distinguish tool and compiler arguments. LibTooling tools gather compilation options from a file with the special name \code{compile\_commands.json}. A tool tries to lookup the file with this name in parent directories of a currently compiled file. If it succeeds, it uses the file to build a compilation database.

When integrating a tool into generated build environments, it is only a matter to add or use an existing generator for a compilation database and create rules for a tool execution. Some of \emph{CMake} \cite{cmake} generators are already able to generate the \emph{JSON} database.

\section{The optimizer implementation}
\label{clang-optimizer}
The libclang`s advantage in the backward compatibility and stability is negligible to achieve the optimizer goal. Even though its disadvantage in creating a new layer on top of Clang code base with the limited access to compiler internals would not affect the tool functionality, it could be an obstacle in the future implementation of new optimization methods and algorithms.

Clang plugins limit the tool to environments with the Clang compiler. Clang plugins also cannot be interactive. They cannot interrupt the compilation process to wait for a user input. Advantages are obvious in the integration to a build environment.

LibTooling and AST matchers libraries provide the possible implementation of the standalone tool with the advantage in the access to compilers internals. The drawback in the backward compatibility is not an issue since any interface changes can be handled easily as the tool is not expected to have large code base. The stability issue is affected by used compiler code. It is only necessary to follow the Clang development more closely. The real issue is with the integration of the new tool into a build environment. Large code bases should be prepared for such integration. For unprepared build environments, it can be an issue, but it is only one-time task.

Overall, advantages of LibTooling and AST matchers libraries are superior to their disadvantages. Furthermore, Clang plugins, LibTooling and AST matchers libraries use the same code base. Therefore, the tool can be enhanced to be used as Clang plugin with less changes.