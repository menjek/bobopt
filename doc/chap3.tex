\chapter{Clang and tooling}
\label{clang}
A support for creating tools for a static analysis of C++ code was very subtle. All compiler front-ends were cumbersome for a usage and individually implementing new is extremely difficult. The situation has changed with Clang providing API for access to C++ code represented as a user-friendly abstract syntax tree structure. Actually, Clang does not provide single tooling API, rather multiple APIs with differences in a usage affecting mainly the way tool accesses AST, range of accessed information and compatibility with older versions. A tool developer can decide whether he wants to sacrifice compatibility to all information front-end internals provide. As Clang develops, there is no guarantee that interfaces in their code base do not change. The tooling interface indicates that Clang targets to diagnostic, code completion and refactoring tools. A support of source-to-source transformation is subtle. Even though there are multiple ways to transform code, the most of them are deprecated.

\section{Abstract Syntax Tree}
The structure Clang provides is not only abstract syntax tree of code, it is a graph that has AST as its sub-graph, and Clang provides mechanisms to traverse this graph as if it was AST. With access to AST node, programmer is able to traverse graph in more ways than he would be able to do with purely AST structure. It allows a developer to optimize his analysing code or perform context sensitive traversal.

Unusually, a class hierarchy of nodes does not have common ancestor. There are two large hierarchies with common ancestors in \code{Decl} and \code{Stmt} classes, some important ones with ancestors in \code{Type} and \code{DeclContext} classes, and many classes accessible only from specific nodes. AST traversal starts in \code{TranslationUnitDecl} node. 

\subsection{Traversal}
\label{clang-ast-traversal}
The template responsible for AST traversal is called \code{RecursiveASTVisitor}. It is implemented as \emph{Curiously Recurring Template Pattern (CRTP)} combined with \emph{visitor design pattern} where a programmer is able to either react on AST node visit or manipulate with a traversal. Due to the character of AST nodes class hierarchy, implementation of a visitor is a bit cumbersome with extensive usage of macros. Therefore, it has nickname \textit{macro monster}. It was promised that it will be once reimplemented so there is no guarantee that interface will not change, even though visitor is massively used in tools. The other approach to traverse AST is to follow edges. It is more useful in a context sensitive traversal.

\section{Source to source transformation}
Developers try to use automatic source-to-source transformations very carefully. Even the simplest case of a code transformation such as symbol renaming is difficult to implement in C++. Before lexical analysis starts, with some exceptions\footnote{The token paste operator \code{\#\#} must be handled when a lexical analysis is happening.}, there is a text-preprocessing phase when source code \emph{text} is transformed to different source code \emph{text}. A preprocessor does not know anything about language syntax or semantic, it is defined as a set of operations on text. During a preprocessing phase, symbols may be created, copied, or erased. It is difficult a task to track symbols origin from output of syntactic analysis to a source code location before preprocessing. Clang uses the integrated preprocessor so looking up a source location from AST is simpler.

There are multiple approaches to do source-to-source transformations based on tool objectives. If tool is supposed to support operations such as symbol renaming or code completion, Clang allows programmer to rewrite source code as a text. \code{Rewriter} class provides this functionality. For a bigger control over code changes in specialized tool wrappers, there is \code{Replacement} class. If a tool is supposed to be used in a build process, it is the best solution to transform AST and output code from this transformed AST for a next build step. There is a facility called \code{TreeTransform} in Clang code base to such purpose.

\subsection{Rewriter}
For the basic source code transformations on the level of text editing, there is the class called \code{Rewriter}. Programmer can create as many instances as necessary, passing them reference to \code{SourceManager}.  User is then allowed to do operations such as insertion, removal, or replacement of text using \code{SourceLocation} or \code{SourceRange} objects, which can be gathered directly from AST node. A text transformation is far from ideal in C++, though it is sufficient for a renaming of symbols or code completion in a text editor where a programmer can immediately repair caused compilation errors.

\subsection{Replacements}
The special wrapper for a bigger control over operations on \code{Rewriter} class is called  \code{Replacement}. When using AST matchers, a callback function is provided with \code{Replacements}, which is a container of \code{Replacement} objects. A callback is free to manipulate with this set, e.g., primarily by adding new objects, but it is not prohibited from removing or editing existing items. At the end of analysis, a tool tests whether an analysis finished correctly, then it checks \code{Replacement} objects for a validity and if all tests pass, it applies those objects on \code{Rewriter} object. After all \code{Replacement} objects are successfully applied to \code{Rewriter} object, the last step is to save affected files. When using \code{Rewriter}, a programmer should implement all the mentioned steps for correct usage. The problem arises when a developer wants to refactor code with compilation errors. \code{RefactoringTool} will not save any changes when an analysis fails. Refactoring tools integrated to a source code text editor cannot use these facilities. Furthermore, text editor tools need to react as fast as possible to user input. A developer should consider using output of \code{Lexer} and avoid phases of a syntactic and semantic analysis\footnote{A similar discussion between developers is conducted on the \emph{clang-format} implementation, see subsection \ref{clang-format}.}.

\subsection{TreeTransform}
The most correct approach to AST transformations according to Clang developers is to use the \code{TreeTransform} facility. If a programmer has an access to non-const nodes, they often provide member functions for a manipulation with \textit{edges} to other nodes. Scout tool, see subsection \ref{scout}, for front-end SIMD optimizations uses this approach even though it is deprecated. The problem is that nodes and edges actually create more complex structure than AST. It is difficult to manipulate with this structure without its detailed knowledge, i.e., a knowledge on the level of Clang developer. A developer must know what is responsible for a node lifetime, what objects can point to the node so deleting the node does not leave any dangling pointer or reference, and all necessary edges starting from the new node so the AST structure will not be incomplete. It is encouraged not to try to modify AST manually.

On the other hand, Clang itself internally transforms AST multiple times in a compilation process. For example, a template instantiation is done on constructed AST effectively transforming it to different one. Since template instantiation can break semantic, it is necessary to test newly created AST in semantic analysis represented by \code{Sema}. This process is handled by the \code{TreeTransform} class. Even though its interface is simple, using CRTP pattern similar to \code{RecursiveASTVisitor}, it is hard to use it in tools. None of Clang tooling interfaces provide an access to the \code{Sema} object. The tooling interface has to be obfuscated and some of its parts has to be reimplemented to catch a reference to the object.

\section{libclang}
The first mentioned, but the least suitable tooling API to achieve the thesis goal is libclang \cite{clang-libclang}, a library with an interface in C language. Its major advantage presented by Clang developers is that it is supposed to be relatively stable and backward compatible. For some developers it can be the crucial feature, but it is negligible to achieve the thesis goal.

Even though libclang provides the interface in a different language than Clang internals, it does not try to hide the way code is represented there. It provides an access to Clang AST\footnote{It is necessary to mention that the access is very limited relatively to Clang internal AST.} in form of abstraction called \emph{Cursor}, which represents single AST element. A tree traversal is achieved using \emph{visitor design pattern}. Part of the library supports a code completion, thus the library fits well as the basis for source code text editors tools.

\section{Plugins}
Clang allows a developer to step into a compilation process in form of plugins \cite{clang-plugins}, dynamic libraries loaded in runtime and running their actions on processed code. Plugins are easy to integrate into a build environment where Clang is used as the compiler. They can be used to break a compilation (e.g. coding rules were broken) or they can produce some output (e.g. code statistics). Because plugins are already a part of single compilation step, they are not suitable for source-to-source transformations. Unlike using libclang, a developer of Clang plugins has full access to AST.

Even though purpose of this thesis is to create the tool used mainly in a build environment, it should not be limited to environments where Clang is used as the compiler or force build environments to integrate Clang in any way.

\section{LibTooling and AST matchers}
LibTooling \cite{clang-libtooling} aims at writing standalone tools such as checkers or refactoring tools. It is easier to run a standalone tool on single file or a specific set of files. On the other hand, it is harder, but definitely possible, to integrate such tool into a build environment where it can be triggered on dependency changes.

The library interface allows a developer full access to the AST structure. Even though the interface tries to hide other compiler internals, it is part of compiler code and can be obfuscated to access them. A developer can take an advantage of other powerful facilities in the compiler such as \code{Lexer}, \code{Parser}, \code{Sema}, \code{SourceManager}, \code{TreeTransform} and more.

AST matchers \cite{clang-matchers} aim at solving the very fundamental operation of matching patterns in AST. The most tools do not invoke action on every single node in AST, rather they invoke action only on specific nodes, e.g., nodes representing member call expression on a specific class. Without AST matchers, a programmer has to traverse whole tree looking for patterns, and eventually invoke an action on matching nodes. Clang provides an extensive library of matcher classes which are designed to be combinable. For example, matchers for the \code{if} statement and function call expression can be combined to the matcher for the \code{if} statement where the condition is an expression in form of a function call.

Both libraries are part of Clang source code and unlike libclang, they do not abstract compiler internal structures. They only represent the way those structures are accessed. Therefore, both libraries can be used interchangeably, e.g., a developer can use AST matchers to seek nodes in AST, then he can run a front-end action on a sub-tree using LibTooling.

\subsection{Internals}
Every compiler front-end uses some powerful facilities in a compilation process. With access to these facilities, a developer has access to more information about source code, and more information allows implementation of more complex algorithms. If those facilities are accessed soon enough, before their invocation, a tool can also affect compilation process.

\subsubsection{Preprocessor}
The \code{Preprocessor} module tightly cooperates with lexer in a transformation of a source code text into lexical tokens. \code{Lexer} class should see code as single source file and it should not handle code preprocessing actions such as resolving file includes and macro expansions. The integrated preprocessor gives Clang tooling libraries an edge over other libraries in an implementation of tools preforming source-to-source transformations. The integrated preprocessor allows better tracking of macro expansions and seeking source code locations from AST nodes. Some of useful information provided by the Clang preprocessor is:

\begin{itemize}
\item A list of all predefined macros.
\item An access to the immediate macro name for a source code location.
\end{itemize}

\subsubsection{Lexer}
\code{Lexer} class provides a simple interface for the transformation of the text buffer into the stream of tokens. Only a forward lexing is supported. Class provides:

\begin{itemize}
\item The source location just past the end of the token specified by the provided source code location.
\item The token as a string for the provided source location.
\end{itemize}

\subsubsection{Parser}
The compiler parser is implemented in the \code{Parser} class. The class implements parser for C family of languages, i.e., C, Objective C, C++ and Objective C++. Clang implements own hand-written recursive-descent parser as several other C and C++ front-ends do\footnote{GCC used the generated Bison/YACC parser, but authors implemented own hand-written parser in the end. Elsa uses the recursive-descent parser as well.}. Due to being recursive-descent and complexity of the C++ grammar, \code{Parser} is a relatively large class in terms of member functions count. However, it is not an interesting class for tools since a majority of member functions handle the grammar rules resolution and are context sensitive.

\subsubsection{Sema}
\code{Parser} feeds the \code{Sema} object with information using the \code{Action} interface. Essentially, when code is being parsed, \code{Parser} notifies \code{Sema}. Based on notifications, the \code{Sema} object constructs the AST structure. After a whole translation unit is parsed, the \code{ActOnEndOfTranslationUnit} action is invoked and \code{Sema} provides \code{ASTConsumer} with constructed AST. This is the point where plugins and LibTooling libraries start code analysis by providing own \code{ASTConsumer} implementation through \code{FrontendAction} interface.

\code{Sema} is one of the most interesting classes for tools from outside of the AST library. It provides information related to:

\begin{itemize}
\item Name lookup.
\item Semantic checks.
\item Code completion.
\end{itemize}

\subsubsection{SourceManager}
The class essential for tools performing source-to-source transformations is called \code{SourceManager}. It is responsible for a source code management on top of a filesystem. It handles loading and caching of source code. Furthermore, the class is able to translate abstract \code{SourceLocation} objects into \emph{spelling} and \emph{expansion} locations. A spelling location is a location where bytes for a specified token come from and expansion location where programmer can see them. For a macro expansion, a spelling location is a location in a macro definition and an expansion location is a location where a macro was expanded. \code{SourceManager} provides some useful information such as:

\begin{itemize}
\item A spelling and expansion line and column numbers.
\item Whether location is in a system header.
\item Whether location is in the main translation unit file.
\item Whether location is in a macro expansion.
\item A memory buffer for translation unit source code.
\item Various macro expansion information.
\end{itemize}

\subsection{Usage}
Clang, as the most other compilers, can receive compilation options such as predefined macros, include directories, forced includes or diagnostic level as command line arguments. A standalone tool must be able to feed a compiler internally with this kind of data. Since a tool can have its own command line arguments, it would be hard to distinguish tool and compiler arguments. LibTooling tools gather compilation options from a file with the special name \code{compile\_commands.json}. A tool tries to lookup the file with this name in parent directories of a currently compiled file. If it succeeds, it uses the found file to build a compilation database.

When integrating a tool into generated build environments, it is only a matter to add or use an existing generator for a compilation database and create rules for a tool execution. Some of \emph{CMake} \cite{cmake} generators are already able to generate \emph{JSON} database.

\section{Optimizer implementation}
\label{clang-optimizer}
The libclang`s advantage in a backward compatibility and stability is negligible to achieve the optimizer goal. Even though its disadvantage in creating a new layer on top of Clang code base with limited access to compiler internals would not affect the tool functionality, it could be an obstacle in the future implementation of new optimization methods and algorithms.

Clang plugins limit the tool to environments with the Clang compiler. Furthermore, if the tool is used only for a diagnostic, generating binary is an overhead. Clang plugins also cannot be interactive. They cannot interrupt a compilation process to wait for a user input. Advantages are obvious in an integration to a build environment.

LibTooling and AST matchers libraries provide a possible implementation of the standalone tool with the advantage in the access to compilers internals. The drawback in a backward compatibility is not an issue since any interface changes can be handled easily as the tool is not expected to have large code base. The stability issue is affected by used compiler code so it is only necessary to follow the Clang development more closely. The real issue is with integration of the new tool into a build environment. Large code bases should be prepared for such integration. For unprepared build environments, it can be an issue, but it is only one-time task.

Overall, advantages of LibTooling and AST matchers libraries are superior to their disadvantages. Furthermore, Clang plugins, LibTooling and AST matchers libraries use the same code base so the tool can be enhanced to be used as the Clang plugin with less changes.