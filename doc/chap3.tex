\chapter{Clang and tooling}
As already mentioned in the previous chapter, support for building tools for static analysis of C++ code was very subtle. There was no support for creating tools for C++ code on amateur, enthusiast level. All compilers front-ends were cumbersome for usage and implementing own front-end individually is extremely difficult. Situation has changed with Clang, a compiler front-end, creating API for accessing C++ code represented as user-friendly abstract syntax tree structure. Actually, Clang does not provide single tooling API, rather multiple APIs with differences in usage affecting mainly the way tool accesses AST, range of accessed information and compatibility with older versions. Tool developer can decide whether he wants to sacrifices compatibility to all information front-end internals provide. As Clang develops, there is no guarantee that even a basic interfaces in their code base do not change. Tooling interface indicates that targeted sets of tools are diagnostic, code completion and refactoring tools. Source-to-source transformation support is subtle. Even though there are multiple ways to transform code, the most of them are deprecated.

\section{Abstract Syntax Tree}
The structure Clang provides is not only abstract syntax tree of code, it is graph that has AST as its sub-graph and Clang provides mechanisms to traverse this graph as it would be AST. Having access to AST node, programmer is able to traverse graph in more ways than he would be able to do with purely AST structure. It allows developer to optimize his analysing code.

Unusually, class hierarchy of nodes does not have common ancestor. There are two large hierarchies with common ancestors in \code{Decl} and \code{Stmt}, some important ones with ancestors in \code{Type} and \code{DeclContext}, and many classes accessible only from specific nodes. AST traversal starts in \code{TranslationUnitDecl} node. 

\subsection{Traversal}
\label{clang-ast-traversal}
Template responsible for AST traversal is called \code{RecursiveASTVisitor}. It is implemented as \emph{Curiously Recurring Template Pattern (CRTP)} combined with \emph{visitor design pattern} where programmer is able to either react on AST node visit or manipulate with traversal. Due to character of AST nodes class hierarchy, implementation of visitor is a bit cumbersome with extensive usage of macros. Therefore, it has nickname \textit{macro monster}. It was promised that it will be once reimplemented so there is no guarantee that interface will not change, even though visitor is massively used in tools. The other approach to traverse AST is to follow edges. It is more useful in context sensitive search.

\section{Source to source transformation}
When it comes to automatic source-to-source transformation, developers try to use it very carefully. Even the simplest case of code refactoring such as symbol renaming is difficult to implement in C++. Before lexical analysis steps in, with some exceptions\footnote{Token paste operator \code{\#\#} needs to be handled when lexical analysis is happening.}, there is text-preprocessing phase when source code \emph{text} is transformed to different source code \emph{text}. Preprocessor does not know anything about language syntax or semantic, it is defined as a set of operations on text. During preprocessing phase, symbols may be created, copied, or erased. It is difficult task to track symbols origin from syntactic analysis output to source code location before preprocessing. The Clang has integrated preprocessor so looking up source location from AST is simpler.

There are multiple approaches to source-to-source transformation based on tool objectives. If tool is supposed to support operations such as symbol renaming or code completion, Clang allows programmer to rewrite source code as text. This functionality is provided by \code{Rewriter} class. For bigger control over code changes in specialized tool wrappers, there is \code{Replacement} class. If tool is supposed to be used in build process, it is the best solution to transform AST and output code for next build step. There is facility called \code{TreeTransform} in Clang code base for such purpose.

\subsection{Rewriter}
Simple interface for source code editing. Programmer can create as many instances as necessary and pass them reference to \code{SourceManager} to make them functional.  User is then allowed to do operations such as insertion, removal, or replacement of text using \code{SourceLocation} or \code{SourceRange}, which can be gathered directly from AST node. Text transformation is far from ideal in C++, though it is sufficient for renaming symbols or code completion in text editor and caused compilation errors can be immediately repaired by programmer.

\subsection{Replacements}
Special wrapper for \code{Rewriter} operations to keep bigger control over text changes is called \code{Replacement}. When using AST matchers, callback function is provided with pointer to \code{Replacements}, which is set of \code{Replacement} objects. Callback is free to manipulate with this set, e.g., primarily by adding new objects, but it is not prohibited from removing or editing existing items. At the end of analysis tool tests whether analysis finished correctly, then it checks \code{Replacement} objects for validity and if all tests pass, it applies those objects on \code{Rewriter} object. After all objects are successfully applied to \code{Rewriter}, the last step is to save affected files. When using \code{Rewriter}, programmer should implement all the mentioned steps for correct usage. The problem arises when tool wants to refactor code with compilation errors. \code{RefactoringTool} will not save any changes when analysis fails. Therefore, refactoring tools that want to be integrated to source code text editor cannot use these facilities. Furthermore, text editor tools need to react as fast as possible to user input. It often may be enough and faster to use output of \code{Lexer} and avoid phases of syntactic and semantic analysis. In such cases, programmers should not use tooling interface rather they should use compiler internals\footnote{Similar discussion between developers is conducted on \emph{clang-format} implementation (\ref{clang-format}).}.

\subsection{TreeTransform}
The most correct way of transforming AST is to use \code{TreeTransform} facility. If programmer has access to non-const nodes, they often provide member functions to manipulate with \textit{edges} to other nodes. Scout (\ref{scout}) tool for front-end SIMD optimizations uses this approach even though it is deprecated. The problem is that nodes and edges actually create more complex structure than AST. It is difficult to manipulate with this structure without its detailed knowledge, i.e., knowledge on the level of Clang developer. Developer needs know what is responsible for node lifetime, what everything can point to it so deleting node does not leave any dangling pointer or reference and all necessary edges starting from new node so AST structure will not be incomplete. It is encouraged not to try to modify AST manually.

AST immutability is widely mentioned in previous text and it can invoke thoughts about AST created and never changed. That is not true. Clang internally transforms AST multiple times in compilation process. For example, template instantiation is done on constructed AST effectively transforming it to different one. Since template instantiation can break semantic, it is necessary to test newly created AST in semantic analysis represented by \code{Sema}. This process is handled by \code{TreeTransform} class. Even though its interface is simple, using CRTP pattern similar to \code{RecursiveASTVisitor}, it is hard to use it in tools. Object needs to be constructed with reference to \code{Sema}, which is hard to access using tooling interface. 

\section{libclang}
The first mentioned, but the least suitable tooling API to achieve thesis goal is libclang, library with interface in C language. Its major advantage presented by Clang developers is that it is supposed to be relatively stable and backward compatible. For some developers it can be crucial feature, but it is negligible to achieve thesis goal.

Even though libclang provides interface in different language than Clang internals, it does not try to hide the way code is represented there. It provides access to Clang AST\footnote{It is necessary to mention that access is very limited relatively to Clang internal AST.} in form of abstraction called \emph{Cursor}, which represents single AST element. Tree traversal is achieved using \emph{visitor design pattern}. Part of library supports code completion and may fit well in source code text editors.

The fact that library is written in C language makes using C++ for tool implementation unwise. Even though it is definitely possible, there are disadvantages in doing so. Resources have to be acquired and released. Programmers tend to use C++ RAII mechanism not only for being exception safe, but also for the code readability and maintenance. It means implementing whole C++ wrapping layer on top of libclang, which wraps Clang internals itself. Writing tool in different language than C would add unnecessary overhead to implementation. 

\section{Plugins}
The Clang, as compiler front-end, allows developer to step into compilation in form of plugins, dynamic libraries loaded in runtime and running their actions on processed code. Plugins are easy to integrate into build environment where Clang is used as compiler. They can be used to break compilation (e.g.  coding rules of company were broken) or they can produce some output (e.g. code statistics). Even so, because they are already part of single compilation step, they are not suitable for source-to-source transformations. Unlike using libclang, developer has full access to AST using plugins.

Even though purpose of this project is to create tool used mainly in build environment, it should not be limited for environments where Clang is used as compiler or force build environments to integrate Clang in any way. Thus, using plugins would lower tool requirements.

\section{LibTooling and AST matchers}
LibTooling aims at writing standalone tools such as checkers or refactoring tools. It is easier to run standalone tool on single file or specific set of files. On the other hand, it is harder, but definitely possible, to integrate such tool into build environment where it can be triggered on dependency changes.

Library interface is like the one of plugins and guarantee full access to AST structure. Even though interface tries to hide other compiler internals, it is part of compiler code and can be obfuscated to access them. Developer can take advantage of other powerful facilities in compiler such as \code{Lexer}, \code{Parser}, \code{Sema}, \code{SourceManager}, \code{TreeTransform} and more.

AST matchers aim at solving the very fundamental operation of matching patterns in AST. The most of tools do not try to invoke action on every single node in AST rather on specific ones. Without AST matchers, the only way to do this is to traverse whole tree looking for patterns and eventually invoke action on matching nodes. Clang provides extensive library of matcher classes that are designed to be combinable. For example, matchers for if statement and function call can be combined to matcher for if statement where condition is expression in form of function call.

Both libraries are part of the Clang source code and unlike libclang, they do not try to abstract compiler internal structures. They only represent the way those structures are accessed. Therefore, both libraries can be used interchangeably, e.g., developer can use AST matchers to lookup nodes in AST and then run front-end action on sub-tree using LibTooling.

\subsection{Internals}
Every compiler uses some powerful facilities in compilation process. Access to them can improve understanding of code. It also allows implementation of more complex algorithms. If those facilities are accessed soon enough, before their invocation, tool can also affect compilation process.

\subsubsection{Preprocessor}
Module tightly cooperates with lexer in transformation of source code text into lexical tokens. \code{Lexer} should see code as single source file and it should not care about code preprocessing actions such as resolving includes and macro expansion. Integrated preprocessor gives Clang tooling an edge over other libraries when deciding what library to use for source-to-source transformation.

\begin{itemize}
\item List of all predefined macros.
\item Access to immediate macro name for source location.
\end{itemize}

\subsubsection{Lexer}
Simple interface for transformation of text buffer into stream of tokens. Only forward lexing is supported.

\begin{itemize}
\item Get source location just past the end of token specified by provided source location.
\item Get token as string for provided source location.
\end{itemize}

\subsubsection{Parser}
Compiler parser for C family of languages, i.e., C, Objective C, C++ and Objective C++. Clang implements own hand-written recursive-descent parser as several other C and C++ front-ends do\footnote{GCC used generated Bison/YACC parser, but authors implemented hand-written parser in the end. Elsa uses recursive-descent parser as well.}. Due to being recursive-descent and complexity of C++ grammar, \code{Parser} is relatively large class in terms of member functions count. However, it is not interesting from tooling point of view since majority of member functions handle grammar rules resolution and are context sensitive.

\subsubsection{Sema}
Parser feeds \code{Sema} object with information using \code{Action} interface. Essentially, when code is being parsed, \code{Parser} notifies \code{Sema} and based on notifications \code{Sema} constructs AST. After whole translation unit is parsed, \code{ActOnEndOfTranslationUnit} action is invoked and \code{Sema} provides \code{ASTConsumer} with constructed AST. This is the point where plugins and LibTooling libraries start code analysis by providing own \code{ASTConsumer} implementation through \code{FrontendAction} interface.

\code{Sema} is one of the most interesting classes for tools from outside of AST library.

\begin{itemize}
\item Name lookup.
\item Semantic checks.
\item Code completion.
\end{itemize}

\subsubsection{SourceManager}
Class is essential for source-to-source transformation tools, because it is responsible for source code management on top of filesystem. It handles loading and caching of source code and it is able to translate abstract \code{SourceLocation} objects into spelling or expansion locations. Spelling location is location where bytes for specified token come from and expansion location where programmer can see them. For macro expansion, spelling location is location in macro definition and expansion location is location where macro was expanded.

\begin{itemize}
\item Spelling and expansion line and column numbers.
\item Whether location is in system header.
\item Whether location is in main TU file.
\item Whether location is in macro expansion.
\item Memory buffer for TU source code.
\item Various macro expansion information.
\end{itemize}

\subsection{Usage}
Clang, as the most other compilers, can receive compilation options such as predefined macros, include directories, forced includes or diagnostic level as command line arguments. Standalone tool must be able to feed compiler internally with this kind of data. Since it can have its own command line arguments, it would be hard to distinguish tool and compiler arguments. LibTooling tools gather compilation options from file with special name \code{compile\_commands.json}. Tool tries to lookup file with this name in parent directories of currently compiled file. If it succeeds, it builds compilation database from this file.

When integrating tool into generated build environments, it is only matter to add or use existing generator for compilation database and create rules for tool execution. Some of the \emph{CMake} generators are already able to generate \emph{JSON} database.